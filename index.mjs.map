{"version":3,"file":"index.mjs","sources":["../lib/main.js"],"sourcesContent":["/**\n* @license Apache-2.0\n*\n* Copyright (c) 2025 The Stdlib Authors.\n*\n* Licensed under the Apache License, Version 2.0 (the \"License\");\n* you may not use this file except in compliance with the License.\n* You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/\n\n'use strict';\n\n// MODULES //\n\nimport copy from '@stdlib/array-base-copy';\nimport ndarray from '@stdlib/ndarray-base-ctor';\nimport getShape from '@stdlib/ndarray-base-shape';\nimport getStrides from '@stdlib/ndarray-base-strides';\nimport getOffset from '@stdlib/ndarray-base-offset';\nimport getOrder from '@stdlib/ndarray-base-order';\nimport getDType from '@stdlib/ndarray-base-dtype';\nimport getData from '@stdlib/ndarray-base-data-buffer';\nimport normalizeIndices from '@stdlib/ndarray-base-normalize-indices';\nimport join from '@stdlib/array-base-join';\nimport zeros from '@stdlib/array-base-zeros';\nimport format from '@stdlib/error-tools-fmtprodmsg';\n\n\n// MAIN //\n\n/**\n* Broadcasts an input ndarray to a target shape while keeping a list of specified dimensions unchanged.\n*\n* ## Notes\n*\n* -   The function expects that each index in the list of dimensions is negative in order to ensure that indices correspond to the same relative position in the output ndarray shape. For example, given an input ndarray shape `[2,X1,X2]` and a desired shape `[6,7,2,Y1,Y2]`, a list of negative dimensions `[-2,-1]` correctly maps the unchanged dimensions `X` in the input ndarray to ignored dimensions `Y` in the provided target shape. Nonnegative indices, however, afford no such mapping. For example, the list of dimensions `[1,2]` corresponds to `[X1,X2]` in the input ndarray shape, but to `[7,2]` in the target shape, which is not desired. By expecting negative indices, we avoid confusion and ensure that users always refer to dimensions relative to the last broadcasted dimension.\n*\n* @param {ndarray} arr - input array\n* @param {NonNegativeIntegerArray} shape - desired shape\n* @param {NegativeIntegerArray} dims - list of dimensions to exclude from broadcasting\n* @throws {Error} input array cannot have more dimensions than the desired shape\n* @throws {Error} broadcasted dimensions in the input array and desired shape must be broadcast compatible\n* @throws {RangeError} dimension indices must not exceed desired shape bounds\n* @throws {Error} must provide unique dimension indices\n* @returns {ndarray} broadcasted array\n*\n* @example\n* import array from '@stdlib/ndarray-array';\n* import getShape from '@stdlib/ndarray-shape';\n*\n* var x = array( [ [ 1, 2, 3 ] ] );\n* // returns <ndarray>\n*\n* var shx = getShape( x );\n* // returns [ 1, 3 ]\n*\n* var y = broadcastArrayExceptDimensions( x, [ 2, 2, 3 ], [ -2 ] );\n* // returns <ndarray>\n*\n* var shy = getShape( y );\n* // returns [ 2, 1, 3 ]\n*\n* var v = y.get( 0, 0, 0 );\n* // returns 1\n*\n* v = y.get( 0, 0, 1 );\n* // returns 2\n*\n* v = y.get( 0, 0, 2 );\n* // returns 3\n*\n* v = y.get( 1, 0, 0 );\n* // returns 1\n*\n* v = y.get( 1, 0, 1 );\n* // returns 2\n*\n* v = y.get( 1, 0, 2 );\n* // returns 3\n*/\nfunction broadcastArrayExceptDimensions( arr, shape, dims ) { // eslint-disable-line id-length\n\tvar strides;\n\tvar idx;\n\tvar dim;\n\tvar sh;\n\tvar st;\n\tvar dl;\n\tvar N;\n\tvar M;\n\tvar d;\n\tvar i;\n\tvar j;\n\tvar k;\n\n\t// Copy input arguments to avoid unintended mutation:\n\tshape = copy( shape );\n\tidx = copy( dims );\n\n\t// Resolve the shape of the input array:\n\tsh = getShape( arr, false );\n\n\tN = shape.length;\n\tM = sh.length;\n\tif ( N < M ) {\n\t\tthrow new Error( format('null0Z') );\n\t}\n\t// Initialize a strides array:\n\tstrides = zeros( N );\n\n\t// Verify that we've been provided a list of unique dimension indices...\n\tdl = idx.length;\n\tidx = normalizeIndices( idx, M-1 );\n\tif ( idx === null ) {\n\t\tthrow new RangeError( format( 'invalid argument. Third argument contains an out-of-bounds dimension index. Value: [%s].', join( dims, ',' ) ) );\n\t}\n\tidx.sort(); // sort in ascending order\n\tif ( idx.length !== dl ) {\n\t\tthrow new Error( format( 'invalid argument. Third argument must contain a list of unique dimension indices. Value: [%s].', join( dims, ',' ) ) );\n\t}\n\tk = idx.length - 1;\n\n\t// Determine the output array strides...\n\tst = getStrides( arr, false );\n\tfor ( i = N-1; i >= 0; i-- ) {\n\t\t// Moving from right-to-left, resolve an index into the input array shape:\n\t\tj = M - N + i; // M-1, M-2, M-3, ..., M-M, ..., M-N with N >= M\n\n\t\t// For prepended singleton dimensions, the stride is zero...\n\t\tif ( j < 0 ) {\n\t\t\tcontinue;\n\t\t}\n\t\t// Check for a dimension being held constant...\n\t\tif ( k >= 0 && idx[ k ] === j ) {\n\t\t\tshape[ i ] = sh[ j ];\n\t\t\tstrides[ i ] = st[ j ];\n\t\t\tk -= 1;\n\t\t\tcontinue;\n\t\t}\n\t\t// Broadcast the current dimension...\n\t\td = sh[ j ];\n\t\tdim = shape[ i ];\n\t\tif ( dim !== 0 && dim < d ) {\n\t\t\tthrow new Error( format( 'null5F', copy( sh ).join( ', ' ), copy( shape ).join( ', ' ), i ) );\n\t\t}\n\t\tif ( d === dim ) {\n\t\t\tstrides[ i ] = st[ j ];\n\t\t} else if ( d === 1 ) {\n\t\t\t// In order to broadcast dimensions, we set the stride for that dimension to zero...\n\t\t\tstrides[ i ] = 0;\n\t\t} else {\n\t\t\t// At this point, we know that `dim > d` and that `d` does not equal `1` (e.g., `dim=3` and `d=2`); in which case, the shapes are considered incompatible (even for desired shapes which are multiples of array dimensions, as might be desired when \"tiling\" an array; e.g., `dim=4` and `d=2`)...\n\t\t\tthrow new Error( format( 'null5G', copy( sh ).join( ', ' ), copy( shape ).join( ', ' ), i ) );\n\t\t}\n\t}\n\treturn ndarray( getDType( arr ), getData( arr ), shape, strides, getOffset( arr ), getOrder( arr ) ); // eslint-disable-line max-len\n}\n\n\n// EXPORTS //\n\nexport default broadcastArrayExceptDimensions;\n"],"names":["broadcastArrayExceptDimensions","arr","shape","dims","strides","idx","dim","sh","st","dl","N","M","d","i","j","k","copy","getShape","length","Error","format","zeros","normalizeIndices","RangeError","join","sort","getStrides","ndarray","getDType","getData","getOffset","getOrder"],"mappings":";;qmCAwFA,SAASA,EAAgCC,EAAKC,EAAOC,GACpD,IAAIC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EAWJ,GARAb,EAAQc,EAAMd,GACdG,EAAMW,EAAMb,GAGZI,EAAKU,EAAUhB,GAAK,IAEpBS,EAAIR,EAAMgB,SACVP,EAAIJ,EAAGW,QAEN,MAAM,IAAIC,MAAOC,EAAO,WAQzB,GALAhB,EAAUiB,EAAOX,GAGjBD,EAAKJ,EAAIa,OAEI,QADbb,EAAMiB,EAAkBjB,EAAKM,EAAE,IAE9B,MAAM,IAAIY,WAAYH,EAAQ,2FAA4FI,EAAMrB,EAAM,OAGvI,GADAE,EAAIoB,OACCpB,EAAIa,SAAWT,EACnB,MAAM,IAAIU,MAAOC,EAAQ,iGAAkGI,EAAMrB,EAAM,OAMxI,IAJAY,EAAIV,EAAIa,OAAS,EAGjBV,EAAKkB,EAAYzB,GAAK,GAChBY,EAAIH,EAAE,EAAGG,GAAK,EAAGA,IAKtB,MAHAC,EAAIH,EAAID,EAAIG,GAGH,GAIT,GAAKE,GAAK,GAAKV,EAAKU,KAAQD,EAC3BZ,EAAOW,GAAMN,EAAIO,GACjBV,EAASS,GAAML,EAAIM,GACnBC,GAAK,MAHN,CASA,GAFAH,EAAIL,EAAIO,GAEK,KADbR,EAAMJ,EAAOW,KACKP,EAAMM,EACvB,MAAM,IAAIO,MAAOC,EAAQ,SAAUJ,EAAMT,GAAKiB,KAAM,MAAQR,EAAMd,GAAQsB,KAAM,MAAQX,IAEzF,GAAKD,IAAMN,EACVF,EAASS,GAAML,EAAIM,OACb,IAAW,IAANF,EAKX,MAAM,IAAIO,MAAOC,EAAQ,SAAUJ,EAAMT,GAAKiB,KAAM,MAAQR,EAAMd,GAAQsB,KAAM,MAAQX,IAHxFT,EAASS,GAAM,CAIf,CAfA,CAiBF,OAAOc,EAASC,EAAU3B,GAAO4B,EAAS5B,GAAOC,EAAOE,EAAS0B,EAAW7B,GAAO8B,EAAU9B,GAC9F"}